# wines data

getwd()
setwd("C://Users//Suruthi//Desktop//Data//Cluster Analysis")

install.packages("cluster")
install.packages("mclust")
install.packages("sqldf")
library("cluster")
library("mclust")
library(sqldf)
library(openxlsx)

data1 <- read.xlsx("wines_input.xlsx")
head(data1)

#**************************************************************************
# To standarize the variables - Data Standardisation : z = (x-mean)/Std.Dev
#**************************************************************************


data <- scale(data1)
data <- data.frame(data)
head(data)

colSums(is.na(data))
#handling missing data, Replacing with zero
data = na.omit(data)
#handling missing data, Replacing with zero
# data$Emp_cnt[is.na(data$Emp_cnt)]<-0


# Assessing cluster tendency
if(!require(clustertend)) install.packages("clustertend")
library(clustertend)
# Compute Hopkins statistic for the dataset
# Hopkins statistic is used to assess the clustering tendency of a dataset by measuring the probability that a given dataset is generated by a uniform data distribution (i.e. no meaningful clusters).
# Null hypothesis: the dataset is uniformly distributed (i.e., no meaningful clusters)
# Alternative hypothesis: the dataset is not uniformly distributed (i.e., contains meaningful clusters)
# If the value of Hopkins statistic is close to 0,it means that the data is highly clusterable. If the value is close to 0.5, that means the data contains no meaningful clusters.
set.seed(123)
hopkins(data, n = nrow(data)-1)

?apply
# Determine number of clusters
# wss<-177*13
wss <- (nrow(data)-1)*sum(apply(data,2,var))
for (i in 2:15) wss[i] <- sum(kmeans(data, 
                                     centers=i)$withinss)
plot(1:15, wss, type="b", xlab="Number of Clusters",
     ylab="Within groups sum of squares")

# K-Means Cluster Analysis
fit1 <- kmeans(data, 3) # 9 cluster solution
summary(fit1)
table(fit1$cluster)
# get cluster means 
aggregate(data,by=list(fit1$cluster),FUN=mean)

# vary parameters for most readable graph
library(cluster) 
clusplot(data, fit1$cluster, color=TRUE, shade=TRUE, 
         labels=2, lines=0)

names(data1)

data1 <- data.frame(data1, fit1$cluster)

write.csv(data1,"cluster.csv")



# iris data
iris
names(iris)
df <- iris[, -5]
df= scale(df)
df=data.frame(df)
# Assessing cluster tendency
if(!require(clustertend)) install.packages("clustertend")
library(clustertend)
# Compute Hopkins statistic for the dataset
# Hopkins statistic is used to assess the clustering tendency of a dataset by measuring the probability that a given dataset is generated by a uniform data distribution (i.e. no meaningful clusters).
# Null hypothesis: the dataset is uniformly distributed (i.e., no meaningful clusters)
# Alternative hypothesis: the dataset is not uniformly distributed (i.e., contains meaningful clusters)
# If the value of Hopkins statistic is close to 0,it means that the data is highly clusterable. If the value is close to 0.5, that means the data contains no meaningful clusters.
set.seed(123)
hopkins(df, n = nrow(df)-1)

# Determine number of clusters
# wss<-149*4
wss <- (nrow(df)-1)*sum(apply(df,2,var))
for (i in 2:15) wss[i] <- sum(kmeans(df, 
                                     centers=i)$withinss)
plot(1:15, wss, type="b", xlab="Number of Clusters",
     ylab="Within groups sum of squares")

# K-Means Cluster Analysis
fit1 <- kmeans(df, 2) # 2 cluster solution
table(fit1$cluster)
# get cluster means 
aggregate(df,by=list(fit1$cluster),FUN=mean)

# vary parameters for most readable graph
library(cluster) 
clusplot(df, fit1$cluster, color=TRUE, shade=TRUE, 
         labels=2, lines=0)


df1 <- data.frame(iris, fit1$cluster)

write.csv(df1,"clusterIris.csv")

# Model on Revenue data
data = read.xlsx("Descriptive Stat.xlsx")
names(data)

# Data Preparation
# Handle Outliers

# Check missing values in the data
colSums(is.na(data))
# Removing the missing records
data=na.omit(data)
# Checking the missing values
colSums(is.na(data))

# Automatic Dummy variable Creation
str(data)
table(data$REGION)
table(data$Model_Type)
table(data$Gender)
CatVars=c(
  "REGION"                    
  , "Model_Type"  
  , "Gender"
)
data[,CatVars]=lapply(data[,CatVars], factor) # Changing Char columns to factor columns
DummyVarList1=data.frame(model.matrix(~ .,data=data[,CatVars]),data[,"ID"])
DummyVarList1=DummyVarList1[,-1]  # removing the first column x intercept
names(DummyVarList1)[ncol(DummyVarList1)]="ID"  # changing the last column name to ID
rm(CatVars)

ModelData1=merge(x = data, y = DummyVarList1, by = "ID", all.x = FALSE)

data2 = ModelData1[c(-1,-4:-6)]
model_data=scale(data2)
model_data=data.frame(model_data)
# Assessing cluster tendency
if(!require(clustertend)) install.packages("clustertend")
library(clustertend)
# Compute Hopkins statistic for the dataset
# Hopkins statistic is used to assess the clustering tendency of a dataset by measuring the probability that a given dataset is generated by a uniform data distribution (i.e. no meaningful clusters).
# Null hypothesis: the dataset is uniformly distributed (i.e., no meaningful clusters)
# Alternative hypothesis: the dataset is not uniformly distributed (i.e., contains meaningful clusters)
# If the value of Hopkins statistic is close to 0,it means that the data is highly clusterable. If the value is close to 0.5, that means the data contains no meaningful clusters.
set.seed(123)
hopkins(model_data, n = nrow(model_data)-1)


# Determine number of clusters

wss <- (nrow(model_data)-1)*sum(apply(model_data,2,var))
for (i in 2:15) wss[i] <- sum(kmeans(model_data, 
                                     centers=i)$withinss)
plot(1:15, wss, type="b", xlab="Number of Clusters",
     ylab="Within groups sum of squares")

# K-Means Cluster Analysis
fit1 <- kmeans(model_data, 5) # 2 cluster solution

# get cluster means 
aggregate(model_data,by=list(fit1$cluster),FUN=mean)

# vary parameters for most readable graph
library(cluster) 
clusplot(model_data, fit1$cluster, color=TRUE, shade=TRUE, 
         labels=2, lines=0)


Customer_Segment <- data.frame(data, fit1$cluster)

write.csv(data1,"cluster.csv")
